diff a/toolkit/tools/pkgparallel/clustering/clustering.go b/toolkit/tools/pkgparallel/clustering/clustering.go	(rejected hunks)
@@ -3,21 +3,36 @@ package clusterise
 import (
 	"math"
 	"reflect"
+	"gonum.org/v1/gonum/graph"
 
 	"microsoft.com/pkggen/internal/pkggraph"
 )
 
-func ShortestPath(g *pkggraph.PkgGraph,u *pkggraph.PkgNode,v *pkggraph.PkgNode) int64 {
+func ShortestPath(g *pkggraph.PkgGraph,u graph.Node,v graph.Node) int64 {
 	if (!g.HasEdgeFromTo(u.ID(),v.ID())){
 		return 0
 	}
 	return 1
 }
+func Union(a, b []graph.Node) []graph.Node{
+	m := make(map[graph.Node]bool)
 
-func CompTopLevels(g *pkggraph.PkgGraph) map[*pkggraph.PkgNode]int64{
-	top:= make(map[*pkggraph.PkgNode]int64)
+	for _, item := range a {
+			m[item] = true
+	}
+
+	for _, item := range b {
+			if _, ok := m[item]; !ok {
+					a = append(a, item)
+			}
+	}
+	return a
+}
+
+func CompTopLevels(g *pkggraph.PkgGraph) map[graph.Node]int64{
+	top:= make(map[graph.Node]int64)
 	V:= g.AllNodes()
-	var source *pkggraph.PkgNode
+	var source graph.Node
 	for _, u := range V{
 		if (reflect.DeepEqual(g.AllNodesFrom(u),V)){
 			source = u
@@ -30,7 +45,7 @@ func CompTopLevels(g *pkggraph.PkgGraph) map[*pkggraph.PkgNode]int64{
 	}
 	return top
 }
-func Contains(s []*pkggraph.PkgNode, e *pkggraph.PkgNode) bool {
+func Contains(s []graph.Node, e graph.Node) bool {
     for _, a := range s {
         if a == e {
             return true
@@ -39,45 +54,45 @@ func Contains(s []*pkggraph.PkgNode, e *pkggraph.PkgNode) bool {
     return false
 }
 
-func DetectCycle(u *pkggraph.PkgNode, v *pkggraph.PkgNode, g pkggraph.PkgGraph, leader map[*pkggraph.PkgNode]*pkggraph.PkgNode, top map[*pkggraph.PkgNode]int64) bool{
-	visited:= make(map[*pkggraph.PkgNode]bool)
+func DetectCycle(u graph.Node, v graph.Node, g *pkggraph.PkgGraph, leader map[graph.Node]graph.Node, top map[graph.Node]int64) bool{
+	visited:= make(map[graph.Node]bool)
 	V:= g.AllNodes()
 	for _,u := range V{
 		visited[u]=false
 	}
 	var t int64
-	var cluster []*pkggraph.PkgNode
+	var cluster []graph.Node
 	for _,node := range V{
 		if (leader[node]==leader[v]){
 			cluster = append(cluster, node)
 		}
 	}
-	t = len(V)
+	t = int64(len(V))
 	for _,node := range cluster{
-		t=math.Min(t, top[node])
+		t= int64(math.Min(float64(t), float64(top[node])))
 	}
-	var q []*pkggraph.PkgNode
+	var q []graph.Node
 	visited[u] = true
 	q = append(q, u)
 	for len(q) > 0 {
-		var w *pkggraph.PkgNode
+		var w graph.Node
 		w, q = q[0], q[1:]
-		for _, node := range g.From(w.ID()) {
+		for _, node := range graph.NodesOf(g.From(w.ID())){
 			if Contains(cluster,node){
 				return true;
 			}
-			if (math.Abs(top[node]-t)<=1){
+			if (int64(math.Abs(float64(top[node]-t)))<=1){
 				if !visited[node] {
 				q = append(q, node)
 				visited[node] = true
 				}
 			}
 		}
-		for _, node := range g.To(w.ID()) {
+		for _, node := range graph.NodesOf(g.To(w.ID())) {
 			if Contains(cluster,node){
 				return true;
 			}
-			if (math.Abs(top[node]-t)<=1){
+			if (int64(math.Abs(float64(top[node]-t)))<=1){
 				if visited[node] {
 					return true;
 				}
@@ -89,12 +104,12 @@ func DetectCycle(u *pkggraph.PkgNode, v *pkggraph.PkgNode, g pkggraph.PkgGraph,
 	return false;
 }
 
-func clusterise(g *pkggraph.PkgGraph) map[*pkggraph.PkgNode]*pkggraph.PkgNode {
+func clusterise(g *pkggraph.PkgGraph) map[graph.Node]graph.Node {
 	top:=CompTopLevels(g)
 	V:= g.AllNodes()
-	markup:= make(map[*pkggraph.PkgNode]bool)
-	markdown:= make(map[*pkggraph.PkgNode]bool)
-	leader:= make(map[*pkggraph.PkgNode]*pkggraph.PkgNode)
+	markup:= make(map[graph.Node]bool)
+	markdown:= make(map[graph.Node]bool)
+	leader:= make(map[graph.Node]graph.Node)
 	for _, u := range V{
 		markup[u] = false
 		markdown[u] = false
@@ -104,11 +119,11 @@ func clusterise(g *pkggraph.PkgGraph) map[*pkggraph.PkgNode]*pkggraph.PkgNode {
 		if (markup[u]&&markdown[u]){
 			continue
 		}
-		for _,v := range Union(g.From(u.ID()), g.To(u.ID())){
-			if (math.Abs(top[u]-top[v])>1){
+		for _,v := range Union(graph.NodesOf(g.From(u.ID())), graph.NodesOf(g.To(u.ID()))){
+			if (int64(math.Abs(float64(top[u]-top[v])))>1){
 				continue
 			}
-			if (Contains(g.From(u.ID()),v)){
+			if (Contains(graph.NodesOf(g.From(u.ID())),v)){
 				if (markup[v]){
 					continue
 				}
@@ -119,7 +134,7 @@ func clusterise(g *pkggraph.PkgGraph) map[*pkggraph.PkgNode]*pkggraph.PkgNode {
 				markup[u]=true
 				markdown[v]=true
 			}
-			if (Contains(g.To(u.ID()),v)){
+			if (Contains(graph.NodesOf(g.To(u.ID())),v)){
 				if (markdown[v]){
 					continue
 				}
