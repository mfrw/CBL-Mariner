diff --git a/toolkit/tools/pkgparallel/clustering.go b/toolkit/tools/pkgparallel/clustering.go
index c7041dcf..c35a3c3b 100644
--- a/toolkit/tools/pkgparallel/clustering.go
+++ b/toolkit/tools/pkgparallel/clustering.go
@@ -18,7 +18,7 @@ func CompTopLevels(g *pkggraph.PkgGraph) map[*pkggraph.PkgNode]int{
	V:= g.AllNodes()
	source:= make(*pkggraph.PkgNode)
	for _, u := range V{
-		if (Union(simple.directedGraph.From(u.ID()), simple.directedGraph.To(u.ID())) == V){
+		if (pkggraph.AllNodesFrom(u)==V){
			source = u
			break
		}
@@ -38,8 +38,54 @@ func Contains(s []*pkggraph.PkgNode, e *pkggraph.PkgNode) bool {
     return false
 }

-func DetectCycle(u *pkggraph.PkgNode, v *pkggraph.PkgNode, g pkggraph.PkgGraph, leader map[*pkggraph.PkgNode]*pkggraph.PkgNode){
-
+func DetectCycle(u *pkggraph.PkgNode, v *pkggraph.PkgNode, g pkggraph.PkgGraph, leader map[*pkggraph.PkgNode]*pkggraph.PkgNode, top map[*pkggraph.PkgNode]int){
+	visited:= make(map[*pkggraph.PkgNode]bool)
+	V:= g.AllNodes()
+	for _,u := range V{
+		visited[u]=false
+	}
+	var t int
+	var cluster []*pkggraph.PkgNode
+	for _,node := range V{
+		if (leader[node]==leader[v]){
+			cluster = append(node)
+		}
+	}
+	t = len(V)
+	for _,node := range cluster{
+		t=Min(t, top[node])
+	}
+	var q []*pkggraph.PkgNode
+	visited[u] = true
+	q = append(q, u)
+	for len(q) > 0 {
+		var w *pkggraph.PkgNode
+		w, q = q[0], q[1:]
+		for _, node := range simple.DirectedGraph.From(w) {
+			if Contains(cluster,node){
+				return true;
+			}
+			if (abs(top[node]-t)<=1){
+				if !visited[node] {
+				q = append(q, node)
+				visited[node] = true
+				}
+			}
+		}
+		for _, node := range simple.DirectedGraph.To(w) {
+			if Contains(cluster,node){
+				return true;
+			}
+			if (abs(top[node]-t)<=1){
+				if visited[node] {
+					return true;
+				}
+				q = append(q, node)
+				visited[node] = true
+			}
+		}
+	}
+	return false;
 }

 func Clusterise(g *pkggraph.PkgGraph, n pkggraph.PkgNode) []*pkggraph.PkgGraph {
@@ -61,20 +107,26 @@ func Clusterise(g *pkggraph.PkgGraph, n pkggraph.PkgNode) []*pkggraph.PkgGraph {
				continue
			}
			if (Contains(simple.directedGraph.From(u.ID()),v)){
-				if (markup[v])
+				if (markup[v]){
					continue
-				if (DetectCycle(u, v, g, leader))
+				}
+				if (DetectCycle(u, v, g, leader, top)){
					continue
+				}
				leader[u]=leader[v]
-				markup[u]=markdown[v]=true
+				markup[u]=true
+				markdown[v]=true
			}
			if (Contains(simple.directedGraph.To(u.ID()),v)){
-				if (markdown[v])
+				if (markdown[v]){
					continue
-				if (DetectCycle(u, v, g, leader))
+				}
+				if (DetectCycle(u, v, g, leader, top)){
					continue
+				}
				leader[u]=leader[v]
-				markdown[u]=markup[v]=true
+				markdown[u]=true
+				markup[v]=true
			}
		}
	}
@@ -82,5 +134,5 @@ func Clusterise(g *pkggraph.PkgGraph, n pkggraph.PkgNode) []*pkggraph.PkgGraph {
 }

 func main() {
-
+
 }
\ No newline at end of file
